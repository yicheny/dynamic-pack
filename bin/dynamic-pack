#!/usr/bin/env node
'use strict';

const argv = require('minimist')(process.argv.slice(2));
const path = require('path');
const fs = require('fs');
const DPError = require('../lib/DPError');
const GlobalData = require('../lib/GlobalData');
const createPrint = require('../lib/createPrint');
const {isNil,getNowFmt} = require('../lib/utils');
const createExecOrder = require('../lib/createExecOrder');
const {readFile, getAbsoluteFilePath, getWinPath} = require('../lib/pathEnhance')

process.title = 'dynamic-pack'

const GLOBAL_KEYS = Object.freeze({
    packInfo:"packInfo"
})
const dpError = new DPError();
const print = createPrint(dpError);
const globalData = new GlobalData();
const execOrder = createExecOrder(print);

tryExecute(
    () => {
        if (argv.h || argv.help) return printHelpInfo();
        if (argv.v || argv.version) return printVersion();
        if (argv.c || argv.config) return setByConfig();
        if (argv.read) return runRead();
        if (argv.time) return runTime();
        print.info("It is not a command provided by dynamic-pack, you can execute dp -h to view the currently supported commands!");
        process.exit();
    },
    null,
    ()=>dpError.createLog())


function printHelpInfo() {
    print.info(getHelpInfo());
    process.exit();

    function getHelpInfo() {
        return [
            'usage: dynamic-pack [path] [options]',
            '',
            'options',
            '-h --help              Print this list and exit',
            '-v --version           Print the current version and exit',
            '-c --config            Configuration file path',
        ].join('\n');
    }
}

function printVersion() {
    print.info('v' + require('../package.json').version);
    process.exit();
}

async function setByConfig() {
    await tryExecute(async () => {
        let originalMainPanel = null;
        const absoluteConfigPath = getAbsoluteFilePath(getConfigPath());
        const dirName = path.dirname(absoluteConfigPath);
        const config = require(absoluteConfigPath);
        dpError.setPath(getResolveName(config.errorLogPath))
        const isRecovery = config.isRecovery;
        const classify = getClassify();
        const classifyConfig = config.classifyConfig[classify];
        const moduleConfig = classifyConfig.moduleConfig;

        dynamic()
        await exeScripts(config.scripts);
        if (isRecovery) recovery();

        function getConfigPath(){
            const c = argv.c || argv.config;
            if(c === true) return './dp.config.json';
            return c;
        }

        function dynamic() {
            setMainPanel();
            print.success('MainPanel successfully processed!');
            replaceModule();
            print.success('Special module successfully processed!');
            createPackInfo()
            print.success('Successfully created PackInfo file!');

            function setMainPanel() {
                if(panelPathNotExist(classifyConfig)) return null;
                const sourceFile = readFile(getResolveName(classifyConfig.sourceFile));
                if (isRecovery) originalMainPanel = readFile(getResolveName(classifyConfig.targetFile));
                writeTargetPanel(sourceFile);
            }

            function createPackInfo(){
                const packDir = config.packInfoDir || './';
                const packName = config.packInfoName || 'packInfo.json';
                const packPath = getResolveName(`${packDir}${packName}`);
                globalData.setData(GLOBAL_KEYS.packInfo,{
                    packPath,
                    packInfo:getPackInfo(packPath)
                })
                const info = {
                    "classify":classify,
                    "updateTime":getNowFmt()
                }
                fs.writeFileSync(packPath,JSON.stringify(info))

                function getPackInfo(filePath){
                    if(fs.existsSync(filePath)) return readFile(filePath);
                    return '';
                }
            }
        }

        async function exeScripts(scripts) {
            const hasScripts = Array.isArray(scripts) && (scripts.length > 0);
            if (!hasScripts) return null;
            print.primary("\nExecute custom scripts!\n");

            //串行
            for(const s of scripts){
                await execOrder(s);
            }

            //并行
            // const orderList = scripts.map((s) => execOrder(s));
            // await Promise.all(orderList);

            print.success("Custom scripts executed successfully!\n")
        }

        function recovery() {
            if(!panelPathNotExist()) writeTargetPanel(originalMainPanel);
            replaceModule('target', 'source');
            const {packInfo,packPath} = globalData.getData(GLOBAL_KEYS.packInfo);
            fs.writeFileSync(packPath,packInfo);

            print.success('Successfully restored to the initial state!');
        }

        //公共方法
        function replaceModule(sourceKey = 'source', targetKey = 'target') {
            if (!Array.isArray(moduleConfig)) return null;
            moduleConfig.forEach((c) => {
                const filePath = getResolveName(c.filePath);
                let file = readFile(filePath);
                c.replaceModules.forEach(x => {
                    file = file.replace(x[sourceKey], x[targetKey]);
                });
                fs.writeFileSync(filePath, file)
            })
        }

        function writeTargetPanel(file) {
            fs.writeFileSync(getResolveName(classifyConfig.targetFile), file);
        }

        function getResolveName(file){
            return getWinPath(path.resolve(dirName,file));
        }

        function panelPathNotExist(){
            if(isNil(classifyConfig.sourceFile)) return true;
            if(isNil(classifyConfig.targetFile)) return true;
        }

        function getClassify(){
            return argv.classify
        }
    })
}

function runTime(){
    const time = argv.time;
    return new Promise((resolve)=>{
        const timeId = setTimeout(()=>{
            resolve(`dp time=${time} current=${getNowFmt()}`);
            clearTimeout(timeId)
        },time*1000)
    },[])
}

function runRead(){
    const readPath = argv.read;
    const fileInfo = readFile(getAbsoluteFilePath(readPath));
    print.success('dp read file information:',fileInfo)
}

//基础方法
async function tryExecute(callback,errorCB,finallyCB) {
    try {
        await exe(callback);
    } catch (error) {
        print.error('dp执行出错：', error);
        await exe(errorCB);
    } finally {
        await exe(finallyCB);
    }

    async function exe(fn){
        if (typeof fn === 'function') return await fn();
    }
}
